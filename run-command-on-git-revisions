#!/bin/bash
#
# This script runs a given command over a range of Git revisions.
#
# The script will bail out if there are uncommitted changes in the current
# directory.
#
# Previous versions of this script would stop when the command being executed
# didn't return 0 or true. 
# The default behaviour for this version is to run the command on all
# revisions unless the user provide a command line option to stop when the
# script returns true or returns false.
#
# The quoting of the revisions has been improved to properly deal with 
# options like; HEAD@{1 month ago}, for the git-rev command.

if [[ $1 == -v ]]; then
    verbose=1
    shift
fi

start_ref=$1
end_ref=$2
test_command=$3

main()
{
    abort_if_dirty_repo
    enforce_usage
    run_tests
}

usage()
{
}

abort_if_dirty_repo()
{
    git diff-index --quiet --cached HEAD
    if [[ $? -ne 0 ]]; then
        echo "You have staged but not committed changes that would be lost! Aborting."
        exit 1
    fi
    git diff-files --quiet
    if [[ $? -ne 0 ]]; then
        echo "You have unstaged changes that would be lost! Aborting."
        exit 1
    fi
    untracked=$(git ls-files --exclude-standard --others)
    if [ -n "$untracked" ]; then
        echo "You have untracked files that could be overwritten! Aborting."
        exit 1
    fi
}

enforce_usage()
{
    if [ -z "$test_command" ]; then
        usage
        exit 1
    fi
}

usage()
{
    echo "usage: `basename $0` start_ref end_ref test_command"
}

run_tests()
{
    revs=`log_command git rev-list --reverse "'${start_ref}'".."'${end_ref}'"`

    for rev in $revs; do
        debug "Checking out: $(git log --oneline -1 $rev)"
        log_command git checkout --quiet $rev
        log_command $test_command
        log_command git reset --hard --quiet
    done
    log_command git checkout --quiet $end_ref
    debug "OK for all revisions!"
}

log_command()
{
    debug "=> $*"
    eval "$@"
}

debug()
{
    if [ $verbose ]; then
        echo $* >&2
    fi
}

main
