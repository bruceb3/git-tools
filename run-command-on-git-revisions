#!/bin/bash
#
# This script runs a given command over a range of Git revisions.
#
# The script will bail out if there are uncommitted changes in the current
# directory.
#
# Previous versions of this script would stop when the command being executed
# didn't return 0 or true. 
# The default behaviour for this version is to run the command on all
# revisions unless the user provide a command line option to stop when the
# script returns true or returns false.
#
# The quoting of the revisions has been improved to properly deal with 
# options like; HEAD@{1 month ago}, for the git-rev command.

PROGNAME=${0##*/}

stop_on_true=0 stop_on_false=0
verbose=0
start_ref= end_ref=
test_command=

main()
{
    run_command_line_options $@
    abort_if_dirty_repo
    run_tests
}

usage()
{
cat <<FFF 1>&2
usage: $PROGNAME [-v] [-t|-f] start_rev end_rev command

 -v verbose output
 -t stop when the command returns true
 -f stop when the command returns false

Default action is to run the command on revisions, ignoring the return
value of the command.
FFF
}

run_command_line_options()
{
    while getopts 'ftv' args $@
    do
        case $args in
            f) stop_on_false=1 ;;
            t) stop_on_true=1 ;;
            v) verbose=1 ;;
            *) break
        esac
    done
    if [[ $stop_on_false = 1 ]] && [[ $stop_on_true = 1 ]]
    then
        echo "Either -f or -t, not both" 1>&2
        usage; exit 1
    fi

    if (( $# < 3 ))
    then
        echo "missing args"
        usage; exit 1
    fi
    # Get rid of any options from the command line.
    while (( $# != 3 ))
    do
        shift
    done
    start_ref=$1
    end_ref=$2
    test_command=$3
}


abort_if_dirty_repo()
{
    git diff-index --quiet --cached HEAD
    if [[ $? -ne 0 ]]; then
        echo "You have staged but not committed changes that would be lost! Aborting."
        exit 1
    fi
    git diff-files --quiet
    if [[ $? -ne 0 ]]; then
        echo "You have unstaged changes that would be lost! Aborting."
        exit 1
    fi
    untracked=$(git ls-files --exclude-standard --others)
    if [ -n "$untracked" ]; then
        echo "You have untracked files that could be overwritten! Aborting."
        exit 1
    fi
}

run_tests()
{
    revs=`log_command git rev-list --reverse "'${start_ref}'".."'${end_ref}'"`

    for rev in $revs; do
        debug "Checking out: $(git log --oneline -1 $rev)"
        log_command git checkout --quiet $rev
        log_command $test_command
        log_command git reset --hard --quiet
    done
    log_command git checkout --quiet $end_ref
    debug "OK for all revisions!"
}

log_command()
{
    debug "=> $*"
    eval "$@"
    if [[ $stop_on_false = 1 ]] && [[ $? -ne 0 ]]
    then
        exit 0
    fi
    if [[ $stop_on_true = 1 ]] && [[ $? -eq 0 ]]
    then
        exit 0
    fi
}

debug()
{
    if [ $verbose ]; then
        echo $* >&2
    fi
}

main $@
